// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package l2Controller

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// ControllerServiceClient is the client API for ControllerService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type ControllerServiceClient interface {
	RegisterMacIP(ctx context.Context, in *MACIPRequest, opts ...grpc.CallOption) (*MACIPResp, error)
	DeregisterMacIP(ctx context.Context, in *MACIPRequest, opts ...grpc.CallOption) (*MACIPResp, error)
	LookupIP(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupResponse, error)
	LookupMac(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupResponse, error)
	BroadcastEndpoints(ctx context.Context, in *VNIDRequest, opts ...grpc.CallOption) (*BroadcastEndpointResponse, error)
	RegisterEP(ctx context.Context, in *VNIDRequest, opts ...grpc.CallOption) (*RegResponse, error)
	DeregisterEP(ctx context.Context, in *VNIDRequest, opts ...grpc.CallOption) (*RegResponse, error)
}

type controllerServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewControllerServiceClient(cc grpc.ClientConnInterface) ControllerServiceClient {
	return &controllerServiceClient{cc}
}

func (c *controllerServiceClient) RegisterMacIP(ctx context.Context, in *MACIPRequest, opts ...grpc.CallOption) (*MACIPResp, error) {
	out := new(MACIPResp)
	err := c.cc.Invoke(ctx, "/vpc.l2Controller.ControllerService/RegisterMacIP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerServiceClient) DeregisterMacIP(ctx context.Context, in *MACIPRequest, opts ...grpc.CallOption) (*MACIPResp, error) {
	out := new(MACIPResp)
	err := c.cc.Invoke(ctx, "/vpc.l2Controller.ControllerService/DeregisterMacIP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerServiceClient) LookupIP(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupResponse, error) {
	out := new(LookupResponse)
	err := c.cc.Invoke(ctx, "/vpc.l2Controller.ControllerService/LookupIP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerServiceClient) LookupMac(ctx context.Context, in *LookupRequest, opts ...grpc.CallOption) (*LookupResponse, error) {
	out := new(LookupResponse)
	err := c.cc.Invoke(ctx, "/vpc.l2Controller.ControllerService/LookupMac", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerServiceClient) BroadcastEndpoints(ctx context.Context, in *VNIDRequest, opts ...grpc.CallOption) (*BroadcastEndpointResponse, error) {
	out := new(BroadcastEndpointResponse)
	err := c.cc.Invoke(ctx, "/vpc.l2Controller.ControllerService/BroadcastEndpoints", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerServiceClient) RegisterEP(ctx context.Context, in *VNIDRequest, opts ...grpc.CallOption) (*RegResponse, error) {
	out := new(RegResponse)
	err := c.cc.Invoke(ctx, "/vpc.l2Controller.ControllerService/RegisterEP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *controllerServiceClient) DeregisterEP(ctx context.Context, in *VNIDRequest, opts ...grpc.CallOption) (*RegResponse, error) {
	out := new(RegResponse)
	err := c.cc.Invoke(ctx, "/vpc.l2Controller.ControllerService/DeregisterEP", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// ControllerServiceServer is the server API for ControllerService service.
// All implementations must embed UnimplementedControllerServiceServer
// for forward compatibility
type ControllerServiceServer interface {
	RegisterMacIP(context.Context, *MACIPRequest) (*MACIPResp, error)
	DeregisterMacIP(context.Context, *MACIPRequest) (*MACIPResp, error)
	LookupIP(context.Context, *LookupRequest) (*LookupResponse, error)
	LookupMac(context.Context, *LookupRequest) (*LookupResponse, error)
	BroadcastEndpoints(context.Context, *VNIDRequest) (*BroadcastEndpointResponse, error)
	RegisterEP(context.Context, *VNIDRequest) (*RegResponse, error)
	DeregisterEP(context.Context, *VNIDRequest) (*RegResponse, error)
	mustEmbedUnimplementedControllerServiceServer()
}

// UnimplementedControllerServiceServer must be embedded to have forward compatible implementations.
type UnimplementedControllerServiceServer struct {
}

func (*UnimplementedControllerServiceServer) RegisterMacIP(context.Context, *MACIPRequest) (*MACIPResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterMacIP not implemented")
}
func (*UnimplementedControllerServiceServer) DeregisterMacIP(context.Context, *MACIPRequest) (*MACIPResp, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeregisterMacIP not implemented")
}
func (*UnimplementedControllerServiceServer) LookupIP(context.Context, *LookupRequest) (*LookupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupIP not implemented")
}
func (*UnimplementedControllerServiceServer) LookupMac(context.Context, *LookupRequest) (*LookupResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method LookupMac not implemented")
}
func (*UnimplementedControllerServiceServer) BroadcastEndpoints(context.Context, *VNIDRequest) (*BroadcastEndpointResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method BroadcastEndpoints not implemented")
}
func (*UnimplementedControllerServiceServer) RegisterEP(context.Context, *VNIDRequest) (*RegResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method RegisterEP not implemented")
}
func (*UnimplementedControllerServiceServer) DeregisterEP(context.Context, *VNIDRequest) (*RegResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method DeregisterEP not implemented")
}
func (*UnimplementedControllerServiceServer) mustEmbedUnimplementedControllerServiceServer() {}

func RegisterControllerServiceServer(s *grpc.Server, srv ControllerServiceServer) {
	s.RegisterService(&_ControllerService_serviceDesc, srv)
}

func _ControllerService_RegisterMacIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MACIPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).RegisterMacIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpc.l2Controller.ControllerService/RegisterMacIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).RegisterMacIP(ctx, req.(*MACIPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerService_DeregisterMacIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(MACIPRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).DeregisterMacIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpc.l2Controller.ControllerService/DeregisterMacIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).DeregisterMacIP(ctx, req.(*MACIPRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerService_LookupIP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).LookupIP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpc.l2Controller.ControllerService/LookupIP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).LookupIP(ctx, req.(*LookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerService_LookupMac_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(LookupRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).LookupMac(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpc.l2Controller.ControllerService/LookupMac",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).LookupMac(ctx, req.(*LookupRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerService_BroadcastEndpoints_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).BroadcastEndpoints(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpc.l2Controller.ControllerService/BroadcastEndpoints",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).BroadcastEndpoints(ctx, req.(*VNIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerService_RegisterEP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).RegisterEP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpc.l2Controller.ControllerService/RegisterEP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).RegisterEP(ctx, req.(*VNIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _ControllerService_DeregisterEP_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VNIDRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(ControllerServiceServer).DeregisterEP(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpc.l2Controller.ControllerService/DeregisterEP",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(ControllerServiceServer).DeregisterEP(ctx, req.(*VNIDRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _ControllerService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vpc.l2Controller.ControllerService",
	HandlerType: (*ControllerServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "RegisterMacIP",
			Handler:    _ControllerService_RegisterMacIP_Handler,
		},
		{
			MethodName: "DeregisterMacIP",
			Handler:    _ControllerService_DeregisterMacIP_Handler,
		},
		{
			MethodName: "LookupIP",
			Handler:    _ControllerService_LookupIP_Handler,
		},
		{
			MethodName: "LookupMac",
			Handler:    _ControllerService_LookupMac_Handler,
		},
		{
			MethodName: "BroadcastEndpoints",
			Handler:    _ControllerService_BroadcastEndpoints_Handler,
		},
		{
			MethodName: "RegisterEP",
			Handler:    _ControllerService_RegisterEP_Handler,
		},
		{
			MethodName: "DeregisterEP",
			Handler:    _ControllerService_DeregisterEP_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "l2Controller.proto",
}
