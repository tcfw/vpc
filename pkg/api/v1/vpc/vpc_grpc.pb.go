// Code generated by protoc-gen-go-grpc. DO NOT EDIT.

package vpc

import (
	context "context"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
)

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion6

// VPCServiceClient is the client API for VPCService service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://pkg.go.dev/google.golang.org/grpc/?tab=doc#ClientConn.NewStream.
type VPCServiceClient interface {
	VPCs(ctx context.Context, in *VPCsRequest, opts ...grpc.CallOption) (*VPCsResponse, error)
	VPCInfo(ctx context.Context, in *VPCInfoRequest, opts ...grpc.CallOption) (*VPCInfoResponse, error)
	Subnets(ctx context.Context, in *VPCInfoRequest, opts ...grpc.CallOption) (*SubnetsResponse, error)
	InternetGWs(ctx context.Context, in *VPCInfoRequest, opts ...grpc.CallOption) (*InternetGWsRespones, error)
}

type vPCServiceClient struct {
	cc grpc.ClientConnInterface
}

func NewVPCServiceClient(cc grpc.ClientConnInterface) VPCServiceClient {
	return &vPCServiceClient{cc}
}

func (c *vPCServiceClient) VPCs(ctx context.Context, in *VPCsRequest, opts ...grpc.CallOption) (*VPCsResponse, error) {
	out := new(VPCsResponse)
	err := c.cc.Invoke(ctx, "/vpc.VPCService/VPCs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPCServiceClient) VPCInfo(ctx context.Context, in *VPCInfoRequest, opts ...grpc.CallOption) (*VPCInfoResponse, error) {
	out := new(VPCInfoResponse)
	err := c.cc.Invoke(ctx, "/vpc.VPCService/VPCInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPCServiceClient) Subnets(ctx context.Context, in *VPCInfoRequest, opts ...grpc.CallOption) (*SubnetsResponse, error) {
	out := new(SubnetsResponse)
	err := c.cc.Invoke(ctx, "/vpc.VPCService/Subnets", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *vPCServiceClient) InternetGWs(ctx context.Context, in *VPCInfoRequest, opts ...grpc.CallOption) (*InternetGWsRespones, error) {
	out := new(InternetGWsRespones)
	err := c.cc.Invoke(ctx, "/vpc.VPCService/InternetGWs", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// VPCServiceServer is the server API for VPCService service.
// All implementations must embed UnimplementedVPCServiceServer
// for forward compatibility
type VPCServiceServer interface {
	VPCs(context.Context, *VPCsRequest) (*VPCsResponse, error)
	VPCInfo(context.Context, *VPCInfoRequest) (*VPCInfoResponse, error)
	Subnets(context.Context, *VPCInfoRequest) (*SubnetsResponse, error)
	InternetGWs(context.Context, *VPCInfoRequest) (*InternetGWsRespones, error)
	mustEmbedUnimplementedVPCServiceServer()
}

// UnimplementedVPCServiceServer must be embedded to have forward compatible implementations.
type UnimplementedVPCServiceServer struct {
}

func (*UnimplementedVPCServiceServer) VPCs(context.Context, *VPCsRequest) (*VPCsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VPCs not implemented")
}
func (*UnimplementedVPCServiceServer) VPCInfo(context.Context, *VPCInfoRequest) (*VPCInfoResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method VPCInfo not implemented")
}
func (*UnimplementedVPCServiceServer) Subnets(context.Context, *VPCInfoRequest) (*SubnetsResponse, error) {
	return nil, status.Errorf(codes.Unimplemented, "method Subnets not implemented")
}
func (*UnimplementedVPCServiceServer) InternetGWs(context.Context, *VPCInfoRequest) (*InternetGWsRespones, error) {
	return nil, status.Errorf(codes.Unimplemented, "method InternetGWs not implemented")
}
func (*UnimplementedVPCServiceServer) mustEmbedUnimplementedVPCServiceServer() {}

func RegisterVPCServiceServer(s *grpc.Server, srv VPCServiceServer) {
	s.RegisterService(&_VPCService_serviceDesc, srv)
}

func _VPCService_VPCs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VPCsRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPCServiceServer).VPCs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpc.VPCService/VPCs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPCServiceServer).VPCs(ctx, req.(*VPCsRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPCService_VPCInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VPCInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPCServiceServer).VPCInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpc.VPCService/VPCInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPCServiceServer).VPCInfo(ctx, req.(*VPCInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPCService_Subnets_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VPCInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPCServiceServer).Subnets(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpc.VPCService/Subnets",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPCServiceServer).Subnets(ctx, req.(*VPCInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

func _VPCService_InternetGWs_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(VPCInfoRequest)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(VPCServiceServer).InternetGWs(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/vpc.VPCService/InternetGWs",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(VPCServiceServer).InternetGWs(ctx, req.(*VPCInfoRequest))
	}
	return interceptor(ctx, in, info, handler)
}

var _VPCService_serviceDesc = grpc.ServiceDesc{
	ServiceName: "vpc.VPCService",
	HandlerType: (*VPCServiceServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "VPCs",
			Handler:    _VPCService_VPCs_Handler,
		},
		{
			MethodName: "VPCInfo",
			Handler:    _VPCService_VPCInfo_Handler,
		},
		{
			MethodName: "Subnets",
			Handler:    _VPCService_Subnets_Handler,
		},
		{
			MethodName: "InternetGWs",
			Handler:    _VPCService_InternetGWs_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "vpc.proto",
}
